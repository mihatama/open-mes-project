{% extends "base.html" %}
{% load md5url %}
{% block content %}
<div class="production-plan-list">
    <h2>生産計画検索</h2>
    <div class="search-filters">
        <form id="searchForm">
            <div class="filter-row">
                <div class="filter-group">
                    <input type="text" id="searchPlanName" name="plan_name" placeholder="計画名">
                </div>
                <div class="filter-group">
                    <input type="text" id="searchProductCode" name="product_code" placeholder="製品コード">
                </div>
                <div class="filter-group">
                    <select id="searchStatus" name="status">
                        <option value="" disabled selected hidden>ステータス</option>
                        <option value="">すべて</option> {# 実際の「すべて」の選択肢 #}
                        <option value="PENDING">未着手</option>
                        <option value="IN_PROGRESS">進行中</option>
                        <option value="COMPLETED">完了</option>
                        <option value="ON_HOLD">保留</option>
                        <option value="CANCELLED">中止</option>
                    </select>
                </div>
                <div class="filter-group">
                    <input type="text" id="searchParentPlan" name="parent_plan_ref" placeholder="親計画ID">
                </div>
            </div>
            <div class="filter-row date-range-group">
                <label>計画開始日:</label>
                <div class="filter-group date-range">
                    <input type="date" id="searchPlannedStartFrom" name="planned_start_from" aria-label="計画開始日 自">
                    <span>～</span>
                    <input type="date" id="searchPlannedStartTo" name="planned_start_to" aria-label="計画開始日 至">
                </div>
                <div class="filter-group-buttons">
                    <button type="submit" id="searchButton" class="button-primary">検索</button>
                    <button type="button" id="clearSearchButton" class="button-danger">クリア</button>
                </div>
            </div>
        </form>
    </div>

    <table id="productionPlanTable">
        <thead>
            <tr>
                <th>計画名</th>
                <th>製品コード</th>
                <th>計画数量</th>
                <th>計画開始日時</th>
                <th>計画終了日時</th>
                <th>ステータス</th>
                <th>親計画ID</th> 
                <th>詳細</th> {# New header for Detail button #}
                <th>材料引当</th> {# Renamed header for Allocate button #}
            </tr>
        </thead>
        <tbody>
            <!-- Data will be inserted here by JavaScript -->
        </tbody>
    </table>
    <div class="pagination-controls">
        <button id="prevPage" disabled>前へ</button>
        <span id="pageInfo"></span>
        <button id="nextPage" disabled>次へ</button>
    </div>
</div>

<style>
    .production-plan-list {
        width: 100%;
        margin-top: 20px;
    }

    .production-plan-list h2 {
        text-align: center;
        margin-bottom: 20px;
    }

    #productionPlanTable {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    #productionPlanTable th,
    #productionPlanTable td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
        vertical-align: top;
    }

    #productionPlanTable th {
        background-color: #f2f2f2;
        font-weight: bold;
    }

    #productionPlanTable tbody tr:nth-child(even) {
        background-color: #f9f9f9;
    }

    #productionPlanTable tbody tr:hover {
        background-color: #f1f1f1;
    }

    .pagination-controls {
        text-align: center;
        margin-top: 20px;
    }

    .pagination-controls button {
        padding: 8px 16px;
        margin: 0 5px;
        cursor: pointer;
    }

    .pagination-controls button:disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }

    /* Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6); /* Slightly darker overlay */
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000; /* Ensure modal is on top */
    }

    .modal-content {
        background-color: white;
        padding: 25px;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        width: 90%;
        max-width: 900px; /* Further increased max-width for a wider popup */
        text-align: left;
    }
    
    .modal-content .detail-grid {
        display: grid;
        grid-template-columns: auto 1fr; /* Label and value */
        gap: 8px 15px; /* Row gap and column gap */
        margin-bottom: 15px;
    }

    .modal-content h3 {
        margin-top: 0;
        margin-bottom: 15px;
        color: #333;
    }

    .modal-actions {
        margin-top: 25px;
        text-align: right;
    }

    .modal-actions button {
        margin-left: 10px;
        padding: 8px 16px;
        cursor: pointer;
    }

    /* Style for right-aligning numeric columns in the parts table */
    .numeric-column {
        text-align: right;
    }

    /* Styles for search filters */
    .search-filters {
        margin-bottom: 20px;
        padding: 15px;
        border: 1px solid #ccc;
        border-radius: 8px; /* Slightly more rounded corners */
        background-color: #f9f9f9;
    }

    .search-filters h2 { /* Changed from h3 to h2 to match the list title */
        margin-top: 0;
        margin-bottom: 15px; /* Increased margin */
        font-size: 1.2em; /* Slightly larger font for the search title */
        border-bottom: 1px solid #eee; /* Add a subtle separator */
        padding-bottom: 10px; /* Space below the separator */
    }

    .filter-row {
        display: flex;
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
        gap: 15px; /* Space between groups in a row */
        margin-bottom: 10px;
    }

    .filter-group {
        display: flex;
        align-items: center;
        flex: 1 1 200px; /* Allow groups to grow/shrink, with a base width */
        /* min-width: 200px; */ /* Adjust this if needed, flex-basis is often better */
    }

    .filter-group input[type="text"],
    .filter-group input[type="date"],      /* datetime-local から date に変更 */
    .filter-group input[type="datetime-local"], /* 念のため残すが、基本的には type="date" を使用 */
    .filter-group select {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        flex-grow: 1;
        box-sizing: border-box; /* Include padding and border in the element's total width and height */
    }
    .date-range-group { display: flex; align-items: center; gap: 5px; margin-bottom: 10px;}
    .date-range-group label { min-width: 90px; font-weight: bold; margin-right: 8px;}
    .date-range { display: flex; align-items: center; flex-grow: 1;}
    .date-range input[type="date"], .date-range input[type="datetime-local"] { flex-grow: 1; min-width: 120px;} /* Further adjusted min-width for date inputs */
    .date-range span { margin: 0 5px; }

    .filter-group-buttons {
        /* margin-top: 15px; */ /* Removed as it's now part of the date-range-group row */
        margin-left: 15px; /* Add some space to the left of the button group, separating it from date inputs */
    }

    .filter-group-buttons button {
        padding: 10px 20px; /* Larger buttons */
        margin-right: 10px;
        cursor: pointer;
        border: none;
        border-radius: 4px;
        font-weight: bold;
    }

    .button-primary { background-color: #4CAF50; color: white; }
    .button-danger { background-color: #f44336; color: white; }
    .button-primary:hover { background-color: #45a049; }
    .button-danger:hover { background-color: #e53935; }

</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const tbody = document.querySelector('#productionPlanTable tbody');
    const baseApiUrl = '/api/production/plans/'; // Base API endpoint
    const prevPageButton = document.getElementById('prevPage');
    const nextPageButton = document.getElementById('nextPage');
    const pageInfoSpan = document.getElementById('pageInfo');

    // Store the current page's plans for easy access by the popup
    let currentPagePlans = [];

    const pageSize = 100;
    const initialUrl = `${baseApiUrl}?page_size=${pageSize}`;

    // Search form elements
    const searchForm = document.getElementById('searchForm');
    const searchButton = document.getElementById('searchButton');
    const clearSearchButton = document.getElementById('clearSearchButton');
    const searchPlanNameInput = document.getElementById('searchPlanName');
    const searchProductCodeInput = document.getElementById('searchProductCode');
    const searchStatusInput = document.getElementById('searchStatus');
    const searchParentPlanInput = document.getElementById('searchParentPlan');
    const searchPlannedStartFromInput = document.getElementById('searchPlannedStartFrom');
    const searchPlannedStartToInput = document.getElementById('searchPlannedStartTo');


    function fetchProductionPlans(url) {
        fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok: ' + response.statusText);
            }
            return response.json();
        })
        .then(data => {
            currentPagePlans = data.results; // Store the fetched plans
            tbody.innerHTML = ''; // Clear existing rows

            if (currentPagePlans && currentPagePlans.length > 0) {
                currentPagePlans.forEach((plan, index) => {
                    const row = tbody.insertRow();
                    row.insertCell().textContent = plan.plan_name || 'N/A';
                    row.insertCell().textContent = plan.product_code || 'N/A';
                    row.insertCell().textContent = plan.planned_quantity;
                    row.insertCell().textContent = plan.planned_start_datetime ? new Date(plan.planned_start_datetime).toLocaleString() : 'N/A';
                    row.insertCell().textContent = plan.planned_end_datetime ? new Date(plan.planned_end_datetime).toLocaleString() : 'N/A';
                    row.insertCell().textContent = plan.status || 'N/A';
                    row.insertCell().textContent = plan.production_plan || 'N/A'; // This is the ID of the parent plan
                    // Remarks, Created At, Updated At are removed from the main table

                    // Add Detail button cell
                    const detailCell = row.insertCell();
                    const detailButton = document.createElement('button');
                    detailButton.textContent = '詳細';
                    detailButton.classList.add('detail-button'); 
                    detailButton.dataset.planIndex = index;
                    detailCell.appendChild(detailButton);

                    // Add Allocate button cell
                    const actionCell = row.insertCell();
                    const allocateButton = document.createElement('button');
                    allocateButton.textContent = '材料引き当て';
                    allocateButton.classList.add('allocate-button'); // Add a class for potential styling
                    allocateButton.dataset.planIndex = index; // Store index relative to currentPagePlans
                    actionCell.appendChild(allocateButton);
                });
            } else {
                const row = tbody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 9; // Adjusted colspan (7 data cols + 2 action cols)
                cell.textContent = '生産計画データがありません。';
            }

            // Update pagination controls
            prevPageButton.disabled = !data.previous;
            if (data.previous) {
                prevPageButton.dataset.url = data.previous;
            } else {
                prevPageButton.removeAttribute('data-url');
            }

            nextPageButton.disabled = !data.next;
            if (data.next) {
                nextPageButton.dataset.url = data.next;
            } else {
                nextPageButton.removeAttribute('data-url');
            }

            // Update page info
            if (data.count > 0) {
                // Use current_page and total_pages from DRF's paginated response
                pageInfoSpan.textContent = `ページ ${data.current_page} / ${data.total_pages} (全 ${data.count} 件)`;
            } else {
                pageInfoSpan.textContent = 'データがありません';
            }
        })
        .catch(error => {
            console.error('Error fetching production plan data:', error);
            tbody.innerHTML = ''; // Clear existing rows on error
            const row = tbody.insertRow();
            const cell = row.insertCell();
            cell.colSpan = 9; // Adjusted colspan
            cell.textContent = 'データの取得中にエラーが発生しました。';
            prevPageButton.disabled = true;
            nextPageButton.disabled = true;
            pageInfoSpan.textContent = 'エラー';
        });
    }

    prevPageButton.addEventListener('click', () => {
        if (prevPageButton.dataset.url) {
            fetchProductionPlans(prevPageButton.dataset.url);
        }
    });

    nextPageButton.addEventListener('click', () => {
        if (nextPageButton.dataset.url) {
            fetchProductionPlans(nextPageButton.dataset.url);
        }
    });

    function buildSearchQuery() {
        const params = new URLSearchParams();
        params.append('page_size', pageSize.toString());

        if (searchPlanNameInput.value) params.append('plan_name', searchPlanNameInput.value);
        if (searchProductCodeInput.value) params.append('product_code', searchProductCodeInput.value);
        if (searchStatusInput.value) params.append('status', searchStatusInput.value);
        if (searchParentPlanInput.value) params.append('production_plan_ref', searchParentPlanInput.value);
        if (searchPlannedStartFromInput.value) params.append('planned_start_datetime_after', searchPlannedStartFromInput.value);
        if (searchPlannedStartToInput.value) params.append('planned_start_datetime_before', searchPlannedStartToInput.value);
        
        return params.toString();
    }

    searchButton.addEventListener('click', (event) => {
        event.preventDefault(); // Prevent form submission
        const query = buildSearchQuery();
        fetchProductionPlans(`${baseApiUrl}?${query}`);
    });

    clearSearchButton.addEventListener('click', () => {
        searchForm.reset(); // Resets form fields
        fetchProductionPlans(initialUrl); // Fetch with default (no search)
    });

    function showDetailPopup(plan) {
        const existingPopup = document.getElementById('detailModal');
        if (existingPopup) {
            existingPopup.remove();
        }

        const modalOverlay = document.createElement('div');
        modalOverlay.id = 'detailModal';
        modalOverlay.classList.add('modal-overlay');

        const modalContent = document.createElement('div');
        modalContent.classList.add('modal-content');

        // Helper to format date or return 'N/A'
        const formatDate = (dateStr) => dateStr ? new Date(dateStr).toLocaleString() : 'N/A';

        modalContent.innerHTML = `
            <h3>生産計画詳細</h3>
            <div class="detail-grid">
                <strong>計画名:</strong>        <span>${plan.plan_name || 'N/A'}</span>
                <strong>製品コード:</strong>    <span>${plan.product_code || 'N/A'}</span>
                <strong>計画数量:</strong>      <span>${plan.planned_quantity}</span>
                <strong>計画開始日時:</strong>  <span>${formatDate(plan.planned_start_datetime)}</span>
                <strong>計画終了日時:</strong>  <span>${formatDate(plan.planned_end_datetime)}</span>
                <strong>実績開始日時:</strong>  <span>${formatDate(plan.actual_start_datetime)}</span>
                <strong>実績終了日時:</strong>  <span>${formatDate(plan.actual_end_datetime)}</span>
                <strong>ステータス:</strong>    <span>${plan.status || 'N/A'}</span>
                <strong>親計画ID:</strong>    <span>${plan.production_plan || 'N/A'}</span>
                <strong>備考:</strong>          <span>${plan.remarks || ''}</span>
                <strong>作成日時:</strong>      <span>${formatDate(plan.created_at)}</span>
                <strong>更新日時:</strong>      <span>${formatDate(plan.updated_at)}</span>
            </div>
            <div class="modal-actions">
                <button id="closeDetailButton">閉じる</button>
            </div>
        `;

        modalOverlay.appendChild(modalContent);
        document.body.appendChild(modalOverlay);

        document.getElementById('closeDetailButton').addEventListener('click', () => {
            modalOverlay.remove();
        });

        // Optional: Close modal if overlay (outside content) is clicked
        modalOverlay.addEventListener('click', function(event) {
            if (event.target === modalOverlay) {
                modalOverlay.remove();
            }
        });
    }

    tbody.addEventListener('click', function(event) {
    });

    function showAllocatePopup(plan) {
        // Remove existing popup if any to prevent duplicates
        const existingPopup = document.getElementById('allocateModal');
        if (existingPopup) {
            existingPopup.remove();
        }

        const modalOverlay = document.createElement('div');
        modalOverlay.id = 'allocateModal';
        modalOverlay.classList.add('modal-overlay');

        const modalContent = document.createElement('div');
        modalContent.classList.add('modal-content');

        modalContent.innerHTML = `
            <h3>材料引き当て確認</h3>
            <p><strong>計画名:</strong> ${plan.plan_name || 'N/A'}</p>
            <p><strong>製品コード:</strong> ${plan.product_code || 'N/A'}</p>
            <p><strong>計画数量:</strong> ${plan.planned_quantity}</p>
            <h4>必要部品一覧</h4>
            <div id="requiredPartsContainer" style="max-height: 200px; overflow-y: auto; border: 1px solid #eee; padding: 10px; margin-top:10px;">
                <p>部品情報を読み込み中...</p>
            </div>
            <hr>
            <div class="modal-actions">
                <button id="confirmAllocationButton" class="button-primary">引き当て実行</button>
                <button id="cancelAllocationButton">キャンセル</button>
            </div>
        `;

        modalOverlay.appendChild(modalContent);
        document.body.appendChild(modalOverlay);

        // Fetch and display required parts
        const requiredPartsContainer = document.getElementById('requiredPartsContainer');

        // Check if plan.id (current plan ID) is valid before making the fetch call.
        // The request is now to use plan.id (current plan's ID) for fetching parts.
        // plan.id should generally be present for any valid plan object.
        if (!plan || typeof plan.id === 'undefined' || plan.id === null) {
            console.error('Error: plan.id (plan ID) is missing or invalid. Cannot fetch required parts.', plan);
            requiredPartsContainer.innerHTML = '<p style="color:red;">計画IDが指定されていないか無効なため、部品情報を取得できません。</p>';
            // Optionally disable the confirm button
            const confirmButton = document.getElementById('confirmAllocationButton');
            if (confirmButton) confirmButton.disabled = true;
            return; // Stop further execution if plan ID is invalid
        }

        // APIエンドポイントをバックエンドのviews.pyで定義したURLに合わせる
        // Fetching parts based on the current plan's ID (plan.id)
        fetch(`/api/production/plans/${plan.id}/required-parts/`)
            .then(async response => {
                if (response.ok) {
                    // For successful responses, we expect JSON.
                    // If it's not JSON, it's an issue with the API's contract.
                    try {
                        const data = await response.json();
                        return { ok: true, data };
                    } catch (e) {
                        // Failed to parse JSON from a 200 OK response
                        console.error("Failed to parse JSON from successful response:", e);
                        throw new Error("サーバーからの正常な応答を解析できませんでした。");
                    }
                } else {
                    // For error responses, try to get a JSON detail message.
                    // If no JSON body, use status text or a generic message.
                    let errorData = null;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        // Ignore if error response body is not JSON
                    }
                    const errorMessage = errorData?.detail || response.statusText || `サーバーエラー (${response.status})`;
                    const error = new Error(errorMessage);
                    error.status = response.status;
                    error.data = errorData;
                    throw error;
                }
            })
            .then(({ data }) => { // Only called if ok: true and JSON parsed successfully
                // Helper function to format quantities: remove .0 if decimal part is zero
                function formatDecimalQuantity(value) {
                    // まず数値に変換してみる
                    const num = parseFloat(value);
                    if (!isNaN(num)) {
                        // 小数部が 0 なら整数で表示
                        if (num % 1 === 0) {
                            return num.toFixed(0);
                        }
                        // 小数部がある場合は元の小数表現を文字列で返す
                        return num.toString();
                    }
                    // 数値にできなければそのまま返す（null や undefined, 文字列）
                    return value;
                }
                if (data && Array.isArray(data) && data.length > 0) {
                    let partsHtml = `
                        <table style="width:100%; font-size:0.9em;">
                            <thead>
                                <tr>
                                    <th>部品コード</th>
                                    <th>部品名</th>
                                    <th>倉庫</th>
                                    <th class="numeric-column">総必要数</th>
                                    <th class="numeric-column">引当済数量</th> {# New Header #}
                                    <th class="numeric-column">現在庫数</th>
                                    <th class="numeric-column">引当数量</th>
                                    <th>単位</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;
                    data.forEach(part => {
                        partsHtml += `
                            <tr data-part-code="${part.part_code || 'N/A'}">
                                <td>${part.part_code || 'N/A'}</td>
                                <td>${part.part_name || 'N/A'}</td>
                                <td>${part.warehouse || 'N/A'}</td>
                                <td class="numeric-column">${formatDecimalQuantity(part.required_quantity)}</td> {# Total Required #}
                                <td class="numeric-column">${part.already_allocated_quantity !== undefined ? formatDecimalQuantity(part.already_allocated_quantity) : 'N/A'}</td> {# Already Allocated #}
                                <td class="numeric-column">${part.inventory_quantity !== undefined ? part.inventory_quantity : 'N/A'}</td> {# Current Inventory #}
                                <td class="numeric-column">
                                    <input 
                                        type="number" 
                                        class="allocation-quantity-input" 
                                        value="${calculateDefaultAllocation(part.required_quantity, part.inventory_quantity, part.already_allocated_quantity)}"
                                        min="0"
                                        style="width: 70px; text-align: right;" /* Added text-align: right */
                                        data-part-code="${part.part_code || 'N/A'}"
                                        data-part-warehouse="${part.warehouse || 'N/A'}"
                                    />
                                </td>
                                <td>${part.unit || 'N/A'}</td>
                            </tr>
                        `;
                    });
                    partsHtml += '</tbody></table>';

                    let finalHtml = '';
                    // Check if the displayed data is dummy data (based on view's logic)
                    const isDummyData = data.some(part => part.part_name && part.part_name.includes("(要BOM実装)"));
                    if (isDummyData) {
                        const warningText = '注: 表示されている部品情報は、実際の部品構成が取得できなかった場合の代替情報です。';
                        finalHtml += `<p style="color:darkorange; font-weight:bold;">${warningText}</p>`;
                    }
                    finalHtml += partsHtml;
                    requiredPartsContainer.innerHTML = finalHtml;

                } else {
                    // This else block handles cases where response is OK (200) but `data` is not a non-empty array.
                    // Based on the current views.py logic for `required_parts`, a 200 OK response
                    // should always contain a non-empty array (either actual parts or dummy parts).
                    // Thus, this specific path might be unreachable if the backend strictly adheres to that logic.
                    // If the API were to change to send 200 OK with an empty list [] for "no parts",
                    // this would display a "no parts" message. For now, it's kept as defensive coding,
                    // though an empty table might also be an acceptable outcome if data is truly empty.
                    requiredPartsContainer.innerHTML = '<p>部品データが予期された形式ではありません、または空です。</p>';
                }
            })
            .catch(error => {
                console.error('Error fetching or processing required parts:', error);
                // error.message should be descriptive from the throw sites.
                // error.status might be present if it was an HTTP error.
                let displayMessage = error.message;
                if (!error.status && !(error instanceof TypeError)) { // TypeError could be network error
                     // Fallback for unexpected errors not carrying a clean message
                    displayMessage = '部品情報の取得中に予期せぬエラーが発生しました。';
                }
                requiredPartsContainer.innerHTML = `<p style="color:red;">${displayMessage}</p>`;
            });

        document.getElementById('cancelAllocationButton').addEventListener('click', () => {
            modalOverlay.remove();
        });

        // Helper function to get CSRF token from cookies
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        document.getElementById('confirmAllocationButton').addEventListener('click', () => {
            const allocationsData = [];
            const allocationInputs = document.querySelectorAll('.allocation-quantity-input');
            let hasMissingWarehouse = false;

            allocationInputs.forEach(input => {
                const partCode = input.dataset.partCode;
                const partWarehouse = input.dataset.partWarehouse;
                const quantity = parseFloat(input.value) || 0;

                if (quantity > 0) { // Only consider items with quantity > 0
                    if (!partWarehouse || partWarehouse === 'N/A') {
                        console.warn(`Part ${partCode} has no specified warehouse. It will be skipped for allocation.`);
                        hasMissingWarehouse = true;
                        // Do not add to allocationsData if warehouse is missing
                    } else {
                        allocationsData.push({
                            part_number: partCode,
                            warehouse: partWarehouse,
                            quantity_to_allocate: quantity // Changed key name
                        });
                    }
                }
            });
            
            if (hasMissingWarehouse) {
                alert('一部の部品で倉庫が指定されていなかったため、それらの部品は引き当て対象から除外されました。');
            }

            if (allocationsData.length === 0) {
                alert('引き当て対象の有効な部品がありません。数量と倉庫を確認してください。');
                return;
            }

            const csrftoken = getCookie('csrftoken');
            const payload = {
                // sales_order_reference is no longer needed in the body for the new API
                allocations: allocationsData
            };
            console.log('引き当て実行ペイロード:', JSON.stringify(payload, null, 2));

            // Updated API endpoint
            fetch(`/api/production/plans/${plan.id}/allocate-materials/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify(payload)
            })
            .then(response => {
                if (response.ok) {
                    return response.json();
                } else {
                    // Try to parse error response for more details
                    return response.json().then(errData => {
                        throw { status: response.status, data: errData };
                    }).catch(() => {
                        // If error response is not JSON or other parsing error
                        throw { status: response.status, data: { error: `サーバーエラー (${response.status})`, detail: response.statusText } };
                    });
                }
            })
            .then(data => {
                console.log('Allocation successful:', data);

                // モーダルの内容を成功メッセージに更新
                // modalContent は showAllocatePopup 関数のスコープで利用可能です
                let successHtml = `
                    <h3>材料引き当て完了</h3>
                    <p>材表の引き当てが完了しました。</p>
                `;

                if (data.message) {
                    // APIからの追加メッセージがあれば表示（改行を<br>に変換）
                    successHtml += `<p>${String(data.message).replace(/\n/g, '<br>')}</p>`;
                }

                // 引き当て結果の詳細を表示 (data.allocations_summary が存在する場合)
                if (data.allocations_summary && Array.isArray(data.allocations_summary) && data.allocations_summary.length > 0) {
                    successHtml += `
                        <h4>引き当て結果詳細:</h4>
                        <div style="max-height: 150px; overflow-y: auto; border: 1px solid #eee; padding: 10px; margin-bottom:15px; font-size: 0.9em;">
                            <table style="width:100%;">
                                <thead>
                                    <tr>
                                        <th>部品番号</th>
                                        <th class="numeric-column">引当数量</th>
                                        <th>ステータス</th>
                                    </tr>
                                </thead>
                                <tbody>
                    `;
                    data.allocations_summary.forEach(item => {
                        successHtml += `
                            <tr>
                                <td>${item.part_number || 'N/A'}</td>
                                <td class="numeric-column">${item.allocated_quantity !== undefined ? item.allocated_quantity : 'N/A'}</td>
                                <td>${item.status || 'N/A'}</td>
                            </tr>
                        `;
                    });
                    successHtml += '</tbody></table></div>';
                }

                successHtml += `
                    <div class="modal-actions">
                        <button id="closeAllocationSuccessButton" class="button-primary">閉じる</button>
                    </div>
                `;
                modalContent.innerHTML = successHtml;

                // ---ここから追加: BroadcastChannelを使用して結果を通知 ---
                try {
                    const bc = new BroadcastChannel('allocation_results_channel');
                    const messagePayload = {
                        type: 'allocationResult',
                        data: data // APIからのレスポンスデータ全体
                    };
                    bc.postMessage(messagePayload);
                    bc.close(); // 送信後にチャネルを閉じる
                    console.log('Allocation result broadcasted to other windows.');
                } catch (e) {
                    console.error('Error broadcasting allocation result:', e);
                }
                // --- ここまで追加 ---

                // 新しく追加された「閉じる」ボタンにイベントリスナーを設定
                const closeButton = modalContent.querySelector('#closeAllocationSuccessButton');
                if (closeButton) {
                    closeButton.addEventListener('click', () => {
                        modalOverlay.remove();
                        // 必要であれば、ここで生産計画一覧を再読み込みします
                        // fetchProductionPlans(initialUrl);
                    });
                }
            })
            .catch(error => {
                console.error('Allocation failed:', error);
                let errorMessage = '材料の引き当てに失敗しました。';
                if (error.data && error.data.error) {
                    errorMessage += `\nサーバーエラー: ${error.data.error}`;
                    if (error.data.details && Array.isArray(error.data.details) && error.data.details.length > 0) {
                        errorMessage += "\n詳細:\n- " + error.data.details.join("\n- ");
                    } else if (error.data.detail) {
                         errorMessage += `\n詳細: ${error.data.detail}`;
                    }
                } else if (error.message) {
                    errorMessage += `\nメッセージ: ${error.message}`;
                }
                alert(errorMessage);
                // Keep modal open for user to see error or adjust quantities
            });
        });

        // Optional: Close modal if overlay (outside content) is clicked
        modalOverlay.addEventListener('click', function(event) {
            if (event.target === modalOverlay) {
                modalOverlay.remove();
            }
        });
    }

    function calculateDefaultAllocation(requiredStr, inventoryStr, alreadyAllocatedStr) {
        const requiredQty = parseFloat(requiredStr);
        const inventoryQty = parseInt(inventoryStr, 10); // inventory_quantity is Int
        const alreadyAllocatedQty = parseFloat(alreadyAllocatedStr);

        const validRequired = isNaN(requiredQty) ? 0 : requiredQty; // Total required for the plan
        const validInventory = isNaN(inventoryQty) ? 0 : inventoryQty;
        const validAlreadyAllocated = isNaN(alreadyAllocatedQty) ? 0 : alreadyAllocatedQty;

        // Calculate how much is still needed (total required - already allocated for this plan)
        const stillNeeded = Math.max(0, validRequired - validAlreadyAllocated);

        // Default allocation is the minimum of what's still needed and what's available in current inventory
        const defaultToAllocate = Math.min(stillNeeded, validInventory);
        
        return Math.max(0, defaultToAllocate); // Ensure the value is not negative
    }

    // Add event listener for the buttons using event delegation
    tbody.addEventListener('click', function(event) {
        const target = event.target;
        if (target.classList.contains('allocate-button')) {
            const planIndex = parseInt(event.target.dataset.planIndex, 10);
            const plan = currentPagePlans[planIndex];
            if (plan) {
                showAllocatePopup(plan);
            }
        } else if (target.classList.contains('detail-button')) {
            const planIndex = parseInt(event.target.dataset.planIndex, 10);
            const plan = currentPagePlans[planIndex];
            if (plan) {
                showDetailPopup(plan);
            }
        }
    });
    // Initial fetch
    fetchProductionPlans(initialUrl);
});
</script>

{% endblock content %}
{% block js_link %}

<script
    src="{% md5url 'js/top.js' %}">
</script>

<link
    rel="stylesheet"
    href="{% md5url 'css/top.css' %}"
    />


{% endblock js_link %}

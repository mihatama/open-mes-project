{% extends "production/base.html" %}
{% load md5url %}
{% block production_content %}
<div class="production-plan-list">
    <h2>生産計画一覧</h2>
    <table id="productionPlanTable">
        <thead>
            <tr>
                <th>計画名</th>
                <th>製品コード</th>
                <th>計画数量</th>
                <th>計画開始日時</th>
                <th>計画終了日時</th>
                <th>ステータス</th>
                <th>親計画ID</th>
                <th>備考</th>
                <th>作成日時</th>
                <th>更新日時</th>
                <th>操作</th> {# Add header for the button column #}
            </tr>
        </thead>
        <tbody>
            <!-- Data will be inserted here by JavaScript -->
        </tbody>
    </table>
    <div class="pagination-controls">
        <button id="prevPage" disabled>前へ</button>
        <span id="pageInfo"></span>
        <button id="nextPage" disabled>次へ</button>
    </div>
</div>

<style>
    .production-plan-list {
        width: 100%;
        margin-top: 20px;
    }

    .production-plan-list h2 {
        text-align: center;
        margin-bottom: 20px;
    }

    #productionPlanTable {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9em;
    }

    #productionPlanTable th,
    #productionPlanTable td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
        vertical-align: top;
    }

    #productionPlanTable th {
        background-color: #f2f2f2;
        font-weight: bold;
    }

    #productionPlanTable tbody tr:nth-child(even) {
        background-color: #f9f9f9;
    }

    #productionPlanTable tbody tr:hover {
        background-color: #f1f1f1;
    }

    .pagination-controls {
        text-align: center;
        margin-top: 20px;
    }

    .pagination-controls button {
        padding: 8px 16px;
        margin: 0 5px;
        cursor: pointer;
    }

    .pagination-controls button:disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }

    /* Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6); /* Slightly darker overlay */
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000; /* Ensure modal is on top */
    }

    .modal-content {
        background-color: white;
        padding: 25px;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        width: 90%;
        max-width: 500px;
        text-align: left;
    }

    .modal-content h3 {
        margin-top: 0;
        margin-bottom: 15px;
        color: #333;
    }

    .modal-actions {
        margin-top: 25px;
        text-align: right;
    }

    .modal-actions button {
        margin-left: 10px;
        padding: 8px 16px;
        cursor: pointer;
    }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const tbody = document.querySelector('#productionPlanTable tbody');
    const baseApiUrl = '/api/production/plans/'; // Base API endpoint
    const prevPageButton = document.getElementById('prevPage');
    const nextPageButton = document.getElementById('nextPage');
    const pageInfoSpan = document.getElementById('pageInfo');

    // Store the current page's plans for easy access by the popup
    let currentPagePlans = [];

    const initialUrl = `${baseApiUrl}?page_size=100`; // Start with page_size=100
    const pageSize = 100;

    function fetchProductionPlans(url) {
        fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok: ' + response.statusText);
            }
            return response.json();
        })
        .then(data => {
            currentPagePlans = data.results; // Store the fetched plans
            tbody.innerHTML = ''; // Clear existing rows

            if (currentPagePlans && currentPagePlans.length > 0) {
                currentPagePlans.forEach((plan, index) => {
                    const row = tbody.insertRow();
                    row.insertCell().textContent = plan.plan_name || 'N/A';
                    row.insertCell().textContent = plan.product_code || 'N/A';
                    row.insertCell().textContent = plan.planned_quantity;
                    row.insertCell().textContent = plan.planned_start_datetime ? new Date(plan.planned_start_datetime).toLocaleString() : 'N/A';
                    row.insertCell().textContent = plan.planned_end_datetime ? new Date(plan.planned_end_datetime).toLocaleString() : 'N/A';
                    row.insertCell().textContent = plan.status || 'N/A';
                    row.insertCell().textContent = plan.production_plan || 'N/A'; // This is the ID of the parent plan
                    row.insertCell().textContent = plan.remarks || '';
                    row.insertCell().textContent = plan.created_at ? new Date(plan.created_at).toLocaleString() : 'N/A';
                    row.insertCell().textContent = plan.updated_at ? new Date(plan.updated_at).toLocaleString() : 'N/A';

                    // Add the button cell
                    const actionCell = row.insertCell();
                    const allocateButton = document.createElement('button');
                    allocateButton.textContent = '材料引き当て';
                    allocateButton.classList.add('allocate-button'); // Add a class for potential styling
                    allocateButton.dataset.planIndex = index; // Store index relative to currentPagePlans
                    actionCell.appendChild(allocateButton);
                });
            } else {
                const row = tbody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 11; // Adjusted colspan to match number of columns
                cell.textContent = '生産計画データがありません。';
            }

            // Update pagination controls
            prevPageButton.disabled = !data.previous;
            if (data.previous) {
                prevPageButton.dataset.url = data.previous;
            } else {
                prevPageButton.removeAttribute('data-url');
            }

            nextPageButton.disabled = !data.next;
            if (data.next) {
                nextPageButton.dataset.url = data.next;
            } else {
                nextPageButton.removeAttribute('data-url');
            }

            // Update page info
            const totalItems = data.count;
            const totalPages = Math.ceil(totalItems / pageSize);
            let currentFetchedPage = 1;

            try {
                const queryString = url.split('?')[1];
                if (queryString) {
                    const params = new URLSearchParams(queryString);
                    if (params.has('page')) {
                        currentFetchedPage = parseInt(params.get('page'), 10);
                    }
                }
            } catch (e) {
                console.warn("Could not parse current page from URL:", url, e);
                // Fallback if URL parsing fails (e.g. unexpected format)
                if (!data.previous) {
                    currentFetchedPage = 1;
                } else if (!data.next) {
                    currentFetchedPage = totalPages;
                }
            }

            if (totalItems > 0) {
                pageInfoSpan.textContent = `ページ ${currentFetchedPage} / ${totalPages} (全 ${totalItems} 件)`;
            } else {
                pageInfoSpan.textContent = 'データがありません';
            }
        })
        .catch(error => {
            console.error('Error fetching production plan data:', error);
            tbody.innerHTML = ''; // Clear existing rows on error
            const row = tbody.insertRow();
            const cell = row.insertCell(); // Adjusted colspan
            cell.colSpan = 11; // Adjusted colspan
            cell.textContent = 'データの取得中にエラーが発生しました。';
            prevPageButton.disabled = true;
            nextPageButton.disabled = true;
            pageInfoSpan.textContent = 'エラー';
        });
    }

    prevPageButton.addEventListener('click', () => {
        if (prevPageButton.dataset.url) {
            fetchProductionPlans(prevPageButton.dataset.url);
        }
    });

    nextPageButton.addEventListener('click', () => {
        if (nextPageButton.dataset.url) {
            fetchProductionPlans(nextPageButton.dataset.url);
        }
    });

    function showAllocatePopup(plan) {
        // Remove existing popup if any to prevent duplicates
        const existingPopup = document.getElementById('allocateModal');
        if (existingPopup) {
            existingPopup.remove();
        }

        const modalOverlay = document.createElement('div');
        modalOverlay.id = 'allocateModal';
        modalOverlay.classList.add('modal-overlay');

        const modalContent = document.createElement('div');
        modalContent.classList.add('modal-content');

        modalContent.innerHTML = `
            <h3>材料引き当て確認</h3>
            <p><strong>計画名:</strong> ${plan.plan_name || 'N/A'}</p>
            <p><strong>製品コード:</strong> ${plan.product_code || 'N/A'}</p>
            <p><strong>計画数量:</strong> ${plan.planned_quantity}</p>
            <h4>必要部品一覧</h4>
            <div id="requiredPartsContainer" style="max-height: 200px; overflow-y: auto; border: 1px solid #eee; padding: 10px; margin-top:10px;">
                <p>部品情報を読み込み中...</p>
            </div>
            <hr>
            <div class="modal-actions">
                <button id="confirmAllocationButton" class="button-primary">引き当て実行</button>
                <button id="cancelAllocationButton">キャンセル</button>
            </div>
        `;

        modalOverlay.appendChild(modalContent);
        document.body.appendChild(modalOverlay);

        // Fetch and display required parts
        const requiredPartsContainer = document.getElementById('requiredPartsContainer');

        // Check if plan.production_plan (parent plan ID) is valid before making the fetch call.
        // The request is to use plan.production_plan for fetching parts.
        // If a plan is a top-level plan, plan.production_plan might be null.
        if (!plan || typeof plan.production_plan === 'undefined' || plan.production_plan === null) {
            console.error('Error: plan.production_plan (parent plan ID) is missing or invalid. Cannot fetch required parts using parent plan ID.', plan);
            requiredPartsContainer.innerHTML = '<p style="color:red;">親計画IDが指定されていないか無効なため、部品情報を取得できません。</p>';
            // Optionally disable the confirm button
            const confirmButton = document.getElementById('confirmAllocationButton');
            if (confirmButton) confirmButton.disabled = true;
            return; // Stop further execution if parent plan ID is invalid
        }

        // APIエンドポイントをバックエンドのviews.pyで定義したURLに合わせる
        // Fetching parts based on the parent plan ID (plan.production_plan) as per request
        fetch(`/api/production/plans/${plan.production_plan}/required-parts/`)
            .then(async response => {
                if (response.ok) {
                    // For successful responses, we expect JSON.
                    // If it's not JSON, it's an issue with the API's contract.
                    try {
                        const data = await response.json();
                        return { ok: true, data };
                    } catch (e) {
                        // Failed to parse JSON from a 200 OK response
                        console.error("Failed to parse JSON from successful response:", e);
                        throw new Error("サーバーからの正常な応答を解析できませんでした。");
                    }
                } else {
                    // For error responses, try to get a JSON detail message.
                    // If no JSON body, use status text or a generic message.
                    let errorData = null;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        // Ignore if error response body is not JSON
                    }
                    const errorMessage = errorData?.detail || response.statusText || `サーバーエラー (${response.status})`;
                    const error = new Error(errorMessage);
                    error.status = response.status;
                    error.data = errorData;
                    throw error;
                }
            })
            .then(({ data }) => { // Only called if ok: true and JSON parsed successfully
                if (data && Array.isArray(data) && data.length > 0) {
                    let partsHtml = `
                        <table style="width:100%; font-size:0.9em;">
                            <thead>
                                <tr>
                                    <th>部品コード</th>
                                    <th>部品名</th>
                                    <th>必要数量</th>
                                    <th>単位</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;
                    data.forEach(part => {
                        partsHtml += `
                            <tr>
                                <td>${part.part_code || 'N/A'}</td>
                                <td>${part.part_name || 'N/A'}</td>
                                <td>${part.required_quantity}</td>
                                <td>${part.unit || 'N/A'}</td>
                            </tr>
                        `;
                    });
                    partsHtml += '</tbody></table>';

                    let finalHtml = '';
                    // Check if the displayed data is dummy data (based on view's logic)
                    const isDummyData = data.some(part => part.part_name && part.part_name.includes("(要BOM実装)"));
                    if (isDummyData) {
                        const warningText = '注: 表示されている部品情報は、実際の部品構成が取得できなかった場合の代替情報です。';
                        finalHtml += `<p style="color:darkorange; font-weight:bold;">${warningText}</p>`;
                    }
                    finalHtml += partsHtml;
                    requiredPartsContainer.innerHTML = finalHtml;

                } else {
                    // This else block handles cases where response is OK (200) but `data` is not a non-empty array.
                    // Based on the current views.py logic for `required_parts`, a 200 OK response
                    // should always contain a non-empty array (either actual parts or dummy parts).
                    // Thus, this specific path might be unreachable if the backend strictly adheres to that logic.
                    // If the API were to change to send 200 OK with an empty list [] for "no parts",
                    // this would display a "no parts" message. For now, it's kept as defensive coding,
                    // though an empty table might also be an acceptable outcome if data is truly empty.
                    requiredPartsContainer.innerHTML = '<p>部品データが予期された形式ではありません、または空です。</p>';
                }
            })
            .catch(error => {
                console.error('Error fetching or processing required parts:', error);
                // error.message should be descriptive from the throw sites.
                // error.status might be present if it was an HTTP error.
                let displayMessage = error.message;
                if (!error.status && !(error instanceof TypeError)) { // TypeError could be network error
                     // Fallback for unexpected errors not carrying a clean message
                    displayMessage = '部品情報の取得中に予期せぬエラーが発生しました。';
                }
                requiredPartsContainer.innerHTML = `<p style="color:red;">${displayMessage}</p>`;
            });

        document.getElementById('cancelAllocationButton').addEventListener('click', () => {
            modalOverlay.remove();
        });

        document.getElementById('confirmAllocationButton').addEventListener('click', () => {
            console.log('引き当て実行がクリックされました。計画ID:', plan.id, '計画詳細:', plan);
            // ここで実際の材料引き当てAPI呼び出しや処理を実装します。
            alert(`計画ID: ${plan.id} (${plan.plan_name}) の材料引き当てを実行します。（仮実装）`);
            modalOverlay.remove(); // Close modal after action
        });

        // Optional: Close modal if overlay (outside content) is clicked
        modalOverlay.addEventListener('click', function(event) {
            if (event.target === modalOverlay) {
                modalOverlay.remove();
            }
        });
    }

    // Add event listener for the buttons using event delegation
    tbody.addEventListener('click', function(event) {
        if (event.target.classList.contains('allocate-button')) {
            const planIndex = parseInt(event.target.dataset.planIndex, 10);
            const plan = currentPagePlans[planIndex];
            if (plan) {
                showAllocatePopup(plan);
            }
        }
    });
    // Initial fetch
    fetchProductionPlans(initialUrl);
});
</script>

{% endblock production_content %}
{% block js_link %}

<script
    src="{% md5url 'js/top.js' %}">
</script>

<link
    rel="stylesheet"
    href="{% md5url 'css/top.css' %}"
    />


{% endblock js_link %}
